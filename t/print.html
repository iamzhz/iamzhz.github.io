<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Thinking of &#x60;Abandon&#x60;</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduce.html"><strong aria-hidden="true">1.</strong> 介绍</a></li><li class="chapter-item expanded "><a href="bugs/fly_away_error.html"><strong aria-hidden="true">2.</strong> 逃 Error</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bugs/unkown_words.html"><strong aria-hidden="true">2.1.</strong> 鈹溾攢鈹€</a></li><li class="chapter-item expanded "><a href="bugs/seg_fault.html"><strong aria-hidden="true">2.2.</strong> 段错误</a></li></ol></li><li class="chapter-item expanded "><a href="parser/index.html"><strong aria-hidden="true">3.</strong> Parser</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="parser/important_cfg.html"><strong aria-hidden="true">3.1.</strong> 文法？文法！</a></li><li class="chapter-item expanded "><a href="parser/cst_ast.html"><strong aria-hidden="true">3.2.</strong> CST 与 AST</a></li><li class="chapter-item expanded "><a href="parser/node1.html"><strong aria-hidden="true">3.3.</strong> 小结：parse 加减乘除</a></li><li class="chapter-item expanded "><a href="parser/display_a_tree.html"><strong aria-hidden="true">3.4.</strong> 打印一棵树</a></li></ol></li><li class="chapter-item expanded "><a href="new_i_found/index.html"><strong aria-hidden="true">4.</strong> 一些对我来说比较新鲜的东西</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="new_i_found/gdb.html"><strong aria-hidden="true">4.1.</strong> GDB 这么好用？</a></li></ol></li><li class="chapter-item expanded "><a href="cfg.html"><strong aria-hidden="true">5.</strong> 截止目前所有的上下文无关文法</a></li><li class="chapter-item expanded "><a href="where_is_it_from.html"><strong aria-hidden="true">6.</strong> 这个类似文档的东西是怎么来的</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Thinking of &#x60;Abandon&#x60;</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<p>这是是用来记录我的 thinking 和 feeling 的地方.<br />
Made by Zhang Haoze (https://github.com/iamzhz)</p>
<p>电子邮件：<code>iamzhz@foxmail.com</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="逃-error"><a class="header" href="#逃-error">逃 Error</a></h1>
<p>“逃 ERROR”，顾名思义。本页记录了一些 Abandon 的一些错误。不包含语法错误，包含好不容易 de 掉的 编译器/连接器 错误、运行时错误、逻辑错误.</p>
<h2 id="include-的顺序"><a class="header" href="#include-的顺序">include 的顺序</a></h2>
<p>在 <code>src/include.h</code>下包含了这个 project 的所有头文件，其中有标准库的，也有 Abandon 中某个部分的头文件，之后让其他的每个编译单元都 include 这个文件。如果该文件的某个顺序错了，那就会让编译器 g++ 报一些某某符号 undefined 的错.<br />我甚至为此写一个注释：</p>
<pre><code class="language-cpp">// pay attention to the order!! (to myself)
</code></pre>
<h2 id="不要在头文件中定义变量"><a class="header" href="#不要在头文件中定义变量">不要在头文件中定义变量！</a></h2>
<p>Once upon a time, 我在某个头文件中加入了类似以下的代码</p>
<pre><code class="language-cpp">PointerManager pmTree;
</code></pre>
<p>然而，因为上面提过的原因，每个编译单元都 include“主头文件”，而“主头文件”会包含每个其他的头文件，所以就会产生多个定义.<br />当然，在编译阶段没报错，但链接时就会报一大堆多重定义的错：<code>multiple definition of pmTree</code> 。<br />我刚开始想到把它放到实现文件（或 源文件）中，但也不行，这样编译器就报错了.<br />Emmmm, 我又想起了一个词—— <strong>extern</strong> .<br />于是，解决这个问题也很简单， 在头文件的定义前加上 <code>extern</code>，把定义（Definition）变为声明（Declaration），在把定义放在实现文件中.</p>
<pre><code class="language-cpp">extern PointerManager pmTree;
</code></pre>
<h2 id="这就是空指针鸭"><a class="header" href="#这就是空指针鸭">这就是空指针鸭</a></h2>
<p>“我要写 parser 辣”：我用一个写了一个类 <code>Tree</code>用来存储抽象语法树（Abstract Syntax Tree, AST ），在我的 <code>Parser</code>类中，我有一些用于解析非终结符的成员函数，每个函数返回一个指向 new 过的一个树的指针，so  ,<br />我在遇到错误的语法时会返回 nullptr，而在这之后我又直接引用了这个空指针，<br />于是，make 过了，运行时系统输出了类似这样的错：</p>
<pre><code>[1]    2841 segmentation fault (core dumped)  ./abandon hello.abn
</code></pre>
<p>并且当前目录还多了个名为<code>core.2841</code>的文件，现请教 GPT-4o 得知，</p>
<blockquote>
<p>在Linux系统中，出现“segmentation fault (core dumped)”错误时，系统通常会生成一个核心转储文件（core dump file）。这个文件包含程序在崩溃时的内存映像和寄存器状态，帮助开发者进行调试和分析。<br />
具体到你的例子中：<br />
● [1]    2841 表示进程ID为2841的程序在后台运行。<br />
● segmentation fault (core dumped) 表示程序由于非法访问内存地址而崩溃，并且系统生成了一个核心转储文件。<br />
生成的文件 core.2841 是核心转储文件，其中 2841 对应的是崩溃的进程ID。该文件包含了程序崩溃时的内存状态、寄存器状态、堆栈内容等信息。开发者可以使用调试工具，如gdb（GNU Debugger），来分析这个核心转储文件，以确定崩溃的原因。</p>
</blockquote>
<p>（我这时使用的是一个云 space，运行的 Linux）<br /><del>这明显是一个比较明显的问题，但当时这个明显的问题显得不那么明显，</del><br />就是说“不知庐山真面目，只缘身在此山中”，我当时想不到这上面，害的我开始埋怨别的函数。<br />最后才领悟“啊，我 return 了个空指针，我又引用了这个空指针”.<br />解决办法就是不用 nullptr 来表示语法错误，于是我又定义了一个全局变量来表示:</p>
<pre><code class="language-cpp">Tree* noneTreeClass = createTree(treeTypeNode_None);
</code></pre>
<h1 id="不要吞我的-token"><a class="header" href="#不要吞我的-token">不要吞我的 token</a></h1>
<p>在试写 parser 后，我的输入是 <code>3+7</code>，而输出的树是</p>
<pre><code>Node Expr
├── Node Term
│   ├── Node Factor
│   │   └── Token Int [3]
│   └── Node ε
└── Node ε
</code></pre>
<p>其文法是</p>
<pre><code>Expr   -&gt; Term Expr'
Expr'  -&gt; + Term Expr' | - Term Expr' | ε
Term   -&gt; Factor Term'
Term'  -&gt; * Factor Term' | / Factor Term' | ε
Factor -&gt; ( Expr ) | Number
</code></pre>
<p>哎，我加号呢？我 7 呢？
debug 后，发现原来是“吞 token”了.</p>
<blockquote>
<p>按照我的规定，parser 里的函数都是先使用现成的 token，后为下一个函数获取新 token; 每个函数最后必须有且只能有一个未使用的 token</p>
</blockquote>
<p>而我的一些函数因为多读了造成了 bug (我称之为“吞 token”，不知道是否有这个名词)<br />
比如以下代码，为 Expr' 写的一个函数 (含有 bug 的)</p>
<pre><code class="language-cpp">Tree* Parser::parse_Expr_() {
    Token tk = this-&gt;lx-&gt;current;   // 获取当前 token
    this-&gt;lx-&gt;getNextToken();       // 为下一个 token 提前读
    
    Tree* tr = createTree(treeTypeNode_Expr_);  // 构建一棵 Expr' 的树 (作为返回值)
    Tree* tr_Term;
    Tree* tr_Expr_;
    if (tk.matchSign("+") || tk.matchSign("-")) {   // 当前 token 是 + 或 - 的符号
        tr-&gt;add(createTree(tk));    // 将当前 token 封装为树加入到 tr 的子结点
    } else {
        return epsilonTreeClass; // 返回 ε
    }

    tr_Term = this-&gt;parse_Term();   // 继续解析 Term
    if (tr_Term == noneTreeClass) return noneTreeClass; // 如果 Term 解析失败, 返回失败
    tr-&gt;add(tr_Term);   // 否则将 Term 的树加入到 tr 的子结点

    tr_Expr_ = this-&gt;parse_Expr_(); // 继续解析 Expr'
    if (tr_Expr_ == noneTreeClass) return noneTreeClass;    // 如果 Expr' 解析失败, 返回失败
    tr-&gt;add(tr_Expr_);  // 否则将 Expr' 的树加入到 tr 的子结点
    return tr;  // 返回解析过后的 Expr' 树
}
</code></pre>
<p>不难发现, 如果输入是 ε 的, 那么它会依次执行</p>
<pre><code class="language-cpp">Token tk = this-&gt;lx-&gt;current; // 未使用的第一个 token (先标记为 token1)
this-&gt;lx-&gt;getNextToken();   // 未使用的第二个 token
Tree* tr = createTree(treeTypeNode_Expr_);
return epsilonTreeClass;
/* 因为定义不会被执行，且对应该示例无用，故弃之*/
</code></pre>
<p>这样它就会一下子读了两个 token，但却都没有使用，会导致其他代码看不到 token1<br />
解决方案：<br />
将代码改为只有返回的不是 ε 时，才 <code>this-&gt;lx-&gt;getNextToken()</code><br />
如下</p>
<pre><code class="language-cpp">Tree* Parser::parse_Expr_() {
    Token tk = this-&gt;lx-&gt;current;
    // 减去了 this-&gt;lx-&gt;getNextToken();
    
    Tree* tr = createTree(treeTypeNode_Expr_);
    Tree* tr_Term;
    Tree* tr_Expr_;
    if (tk.matchSign("+") || tk.matchSign("-")) {
        tr-&gt;add(createTree(tk));
        this-&gt;lx-&gt;getNextToken(); // 增加了
    } else {
        return epsilonTreeClass; 
    }

    tr_Term = this-&gt;parse_Term();
    if (tr_Term == noneTreeClass) return noneTreeClass;
    tr-&gt;add(tr_Term);

    tr_Expr_ = this-&gt;parse_Expr_();
    if (tr_Expr_ == noneTreeClass) return noneTreeClass;
    tr-&gt;add(tr_Expr_);
    return tr;
}
</code></pre>
<p>其实也就是把 <code>this-&gt;lx-&gt;getNextToken()</code> 换了个位置，<br />
其他函数也有这个 bug，解决方法亦同</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="鈹溾攢鈹"><a class="header" href="#鈹溾攢鈹">鈹溾攢鈹€</a></h1>
<p>是的，标题你没有看错，也不是你编码的问题<br />
Just now，我的 parse 加减乘除写好了</p>
<h2 id="问题描述"><a class="header" href="#问题描述">问题描述</a></h2>
<p>我在 Web 上的 MarsCode(Linux Debian) 写的了一些代码，在上面 push 到了 GitHub，此时此刻，我要把它 pull 到本地(Windows 11)<br />
嗯？有 Error？算了重新 clone 吧<br />
clone 好了，run 一下<br />
emmmm.. 什么东西？</p>
<pre><code>$ ./abandon hello.abn
Input File: hello.abn 
Output File: 
Node Expr
鈹溾攢鈹€ Node Term
鈹?  
</code></pre>
<p>正确结果应该是</p>
<pre><code>➜  Abandon git:(main) ./abandon hello.abn 
Input File: hello.abn 
Output File: 
Node Expr
├── Node Term
│   ├── Node Factor
│   │   └── Node Expr
│   │   │   ├── Node Term
│   │   │   │   ├── Node Factor
│   │   │   │   │   └── Token Int [10]
│   │   │   │   └── Node ε
│   │   │   └── Node Expr'
│   │   │   │   ├── Token Sign [-]
│   │   │   │   ├── Node Term
│   │   │   │   │   ├── Node Factor
│   │   │   │   │   │   └── Token Int [2]
│   │   │   │   │   └── Node ε
│   │   │   │   └── Node ε
│   └── Node Term'
│   │   ├── Token Sign [*]
│   │   ├── Node Factor
│   │   │   └── Token Int [4]
│   │   └── Node ε
└── Node ε
[free] 0x564e6680b5e0
[free] 0x564e6680b640
[free] 0x564e6680b6c0
[free] 0x564e6680b750
[free] 0x564e6680b7b0
[free] 0x564e6680b860
[free] 0x564e6680b8c0
[free] 0x564e6680b920
[free] 0x564e6680b9a0
[free] 0x564e6680ba90
[free] 0x564e6680bb10
[free] 0x564e6680bb70
[free] 0x564e6680bbd0
[free] 0x564e6680bc70
[free] 0x564e6680bcf0
[free] 0x564e6680bd50
[free] 0x564e6680bdb0
[free] 0x564e6680bf40
[free] 0x564e6680bfa0
[free] 0x564e6680c040
[free] 0x564e6680c0d0
</code></pre>
<p>并且，并且！我这之中的我的<code>hello.abn</code>中的文件内容完全一样<br />
现在(2024/8/5 19:28)还没有解决，稍等</p>
<h2 id="解决过程"><a class="header" href="#解决过程">解决过程</a></h2>
<ul>
<li>19:28 刚刚开始</li>
<li>19:41 暂无头绪</li>
<li>19:47 我一气之下把在 Windows 下的文件的 UTF-8 编码全改成 Chinese 2312，现在好了（我就知道跟编码有关<br />
只是我不解我代码里全是 ASCII 中的字符，为什么会与编码...</li>
<li>吃了顿饭</li>
<li>21:05 全部又改为 UTF-8，又可以... 这就是玄学吗？</li>
</ul>
<p>如果我有幸让您看到了这几段字，并且您知道原因的话(不知道也没关系)...请给我发 email <code>iamzhz@foxmail.com</code>，感谢，如果没人看到的话就算了<br />
P.S. 我所 clone 的 commit 的 hash 值是 <a href="https://github.com/iamzhz/Abandon/tree/ae8546c4b3c72b075b3ac2c1675ee70ae8145557"><code>ae8546c4b3c72b075b3ac2c1675ee70ae8145557</code></a></p>
<h2 id="86-更新"><a class="header" href="#86-更新">8/6 更新</a></h2>
<p>我才发现我好像确实用了 ASCII 外的字符 ε 和 制表符(不是指 tab)，是我没注意到<br />
好吧我悟了<br />
我我乱码改为 ε，重新 make 了<br />
于是</p>
<pre><code>PS D:\zhz\v\Abandon&gt; ./abandon hello.abn
Input File: hello.abn 
Output File:
Node Expr
锟斤拷锟斤拷锟斤拷 Node Term
锟斤拷   锟斤拷锟斤拷锟斤拷 Node Factor
锟斤拷   锟斤拷   锟斤拷锟斤拷锟斤拷 Node Expr
锟斤拷   锟斤拷   锟斤拷   锟斤拷锟斤拷锟斤拷 Node Term
锟斤拷   锟斤拷   锟斤拷   锟斤拷   锟斤拷锟斤拷锟斤拷 Node Factor
锟斤拷   锟斤拷   锟斤拷   锟斤拷   锟斤拷   锟斤拷锟斤拷锟斤拷 Token Int [10]
锟斤拷   锟斤拷   锟斤拷   锟斤拷   锟斤拷锟斤拷锟斤拷 Node 蔚
锟斤拷   锟斤拷   锟斤拷   锟斤拷锟斤拷锟斤拷 Node Expr'
锟斤拷   锟斤拷   锟斤拷   锟斤拷   锟斤拷锟斤拷锟斤拷 Token Sign [-]
锟斤拷   锟斤拷   锟斤拷   锟斤拷   锟斤拷锟斤拷锟斤拷 Node Term
锟斤拷   锟斤拷   锟斤拷   锟斤拷   锟斤拷   锟斤拷锟斤拷锟斤拷 Node Factor
锟斤拷   锟斤拷   锟斤拷   锟斤拷   锟斤拷   锟斤拷   锟斤拷锟斤拷锟斤拷 Token Int [2]
锟斤拷   锟斤拷   锟斤拷   锟斤拷   锟斤拷   锟斤拷锟斤拷锟斤拷 Node 蔚
锟斤拷   锟斤拷   锟斤拷   锟斤拷   锟斤拷锟斤拷锟斤拷 Node 蔚
锟斤拷   锟斤拷锟斤拷锟斤拷 Node Term'
锟斤拷   锟斤拷   锟斤拷锟斤拷锟斤拷 Token Sign [*]
锟斤拷   锟斤拷   锟斤拷锟斤拷锟斤拷 Node Factor
锟斤拷   锟斤拷   锟斤拷   锟斤拷锟斤拷锟斤拷 Token Int [4]
锟斤拷   锟斤拷   锟斤拷锟斤拷锟斤拷 Node 蔚
锟斤拷锟斤拷锟斤拷 Node 蔚
</code></pre>
<p>这就是传说中的 锟斤拷 吗？</p>
<h2 id="但是我想用-utf-8-编码啊"><a class="header" href="#但是我想用-utf-8-编码啊">但是我想用 UTF-8 编码啊？！</a></h2>
<p>搜索“Windows gcc utf-8”，emmmmmm，只要在编译时加上 <code>-finput-charset=UTF-8 -fexec-charset=GBK</code>，就可以啦。于是我的 makefile 变成这样了 (不过我不会把它 push 到 Github 上)</p>
<pre><code class="language-makefile">cc := g++
std := -std=c++11
abandon: src/*.cc src/*/*.cc
	$(cc) $^ -o $@ $(std) -g -finput-charset=UTF-8 -fexec-charset=GBK
</code></pre>
<p>完美</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="段错误"><a class="header" href="#段错误">段错误</a></h1>
<p>嗯.... 经过没几天的 code 之后，发现好多的段错误其实都是引用了空指针（<code>nullptr</code>）</p>
<p>完毕</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parser"><a class="header" href="#parser">Parser</a></h1>
<p>记录了关于语法分析器的东西</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文法文法"><a class="header" href="#文法文法">文法？文法！</a></h1>
<h2 id="前情提要-可以跳过"><a class="header" href="#前情提要-可以跳过">前情提要 (可以跳过)</a></h2>
<p>TBH，我在未写语法分析时，认为：</p>
<pre><code>文法？有必要吗？我觉得我到时候写 parser 的时候能够应该能顺着自己的心写出来，
我还需要它？
(真实心理)
</code></pre>
<p>于是，<br />
我写 parser 的之前，思考了一下实现方法，<br />
于是，<br />
我只能又捧读龙书，重视起文法了.</p>
<h2 id="上下文无关文法"><a class="header" href="#上下文无关文法">上下文无关文法</a></h2>
<ul>
<li><strong>上下文无光文法</strong>（Context-Free Grammar，CFG），以下简称为<strong>文法</strong>.</li>
<li><strong>终结符</strong> (Non-terminal) 语法树中的最某端的节点，代表一个 token.</li>
<li><strong>非终结符</strong> (Terminal) 不是语法树中的最某端的节点的节点，代表一群树状的 token(s).</li>
</ul>
<p>文法通常表示为 \(A\to \alpha\), 左侧部分 \(A\) 称为 非终结符，右侧的 \(\alpha\) 被称为<strong>生产式</strong>(Production) 或 <strong>右部</strong> (Right-hand side, RHS)</p>
<ul>
<li><strong>生产式</strong> 是由 终结符 和/或 非终结符 组成的符号序列：也就是一堆由 终结符 和(或) 非终结符 堆成的东西. 生产式 表示了左侧非终结符.</li>
</ul>
<p>以下是处理加减乘除及括号运算的文法(式1)</p>
<pre><code>Expr   -&gt; Expr + Term | Expr - Term | Term
Term   -&gt; Term * Factor | Term / Factor | Factor
Factor -&gt; ( Expr ) | Number
</code></pre>
<p>其中，<code>|</code> 用于分割相同非终结符中可能的不同的生产式，可以理解为 “或”.<br />
虽然但是，式1包含<strong>左递归</strong>.<br />
假如用此式<strong>最左推导</strong>(Leftmost Derivation)某些终结符符号(如<code>1+2</code>)，它会陷入 Expr 的无穷循环.</p>
<p>因此放入到代码环境需要改为无左递归版本，如下(式2)</p>
<pre><code>Expr   -&gt; Term Expr'
Expr'  -&gt; + Term Expr' | - Term Expr' | ε
Term   -&gt; Factor Term'
Term'  -&gt; * Factor Term' | / Factor Term' | ε
Factor -&gt; ( Expr ) | Number
</code></pre>
<p>其中，<code>ε</code> 为空集，也就是啥都不需要，<br />
像这样把它变为<strong>右递归</strong>的做法，叫做<strong>消除左递归</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cst-与-ast"><a class="header" href="#cst-与-ast">CST 与 AST</a></h1>
<p>原来树与树是不同的？我还以为所有的都叫 AST 抽象语法树</p>
<h2 id="cst"><a class="header" href="#cst">CST</a></h2>
<p><strong>CST</strong>（Concrete Syntax Tree，具体语法树）<br />
CST 是对输入源代码的一种更接近原始语法结构的直接表示，它保留了更多的语法细节，包括可能的冗余和不必要的信息<br />
像这样</p>
<pre><code>Node Expr
├── Node Term
│   ├── Node Factor
│   │   └── Node Expr
│   │       ├── Node Term
│   │       │   ├── Node Factor
│   │       │   │   └── Token Int [10]
│   │       │   └── Node ε
│   │       └── Node Expr'
│   │           ├── Token Sign [-]
│   │           ├── Node Term
│   │           │   ├── Node Factor
│   │           │   │   └── Token Int [2]
│   │           │   └── Node ε
│   │           └── Node ε
│   └── Node Term'
│       ├── Token Sign [*]
│       ├── Node Factor
│       │   └── Token Int [4]
│       └── Node ε
└── Node ε
</code></pre>
<h1 id="ast"><a class="header" href="#ast">AST</a></h1>
<p><strong>AST</strong> （Abstract Syntax Tree，抽象语法树）<br />
也就是把 CST 去掉没用的 ε 与只包含一个子节点的节点，但保留子节点<br />
像这样</p>
<pre><code>Node Expr
├── Node Factor
│   ├── token Int [10]
│   └── Node Expr'
│       ├── Token Sign [-]
│       └── Token Int [2]
└── Node Term'
    ├── Token Sign [*]
    └── Token Int [4]
</code></pre>
<p>这么样？看着是不是清净很多？</p>
<h2 id="thinking"><a class="header" href="#thinking">Thinking</a></h2>
<p>CST 可以直接生成的，也可以直接生成 AST，不过可能会没直接生成 CST 简单. 我生成的就是 CST, display 出来的树比较难看, 所以, 我还想往 Tree 类再加一个成员函数, 起名为 <code>cst2ast()</code>, 它在 CST 生成之后执行, 通过遍历一棵树将使得其变得更抽象, 应该也不算难</p>
<h2 id="半晌后更新"><a class="header" href="#半晌后更新">半晌后更新</a></h2>
<p>已经写成了, 输出:</p>
<pre><code>Node Term
├── Node Expr
│   ├── Token Int [10]
│   └── Node Expr'
│   │   ├── Token Sign [-]
│   │   └── Token Int [2]
└── Node Term'
│   ├── Token Sign [*]
│   └── Token Int [4]
</code></pre>
<p>code:</p>
<pre><code class="language-cpp">Tree* Parser::cst2ast(Tree* tr) {
    if (tr-&gt;type == treeType_Token) return tr;

    std::vector&lt;Tree*&gt; &amp; c = tr-&gt;children; // 酱紫写起来比较好看
    for (auto it = c.begin();  it != c.end();  /*这里是空的*/) {
        if ((*it)-&gt;type == treeType_Node &amp;&amp; (*it)-&gt;label == treeTypeNode_Epsilon) { // 如果是空集
            it = c.erase(it); // “擦”去它
        } else { // 否则 (废话)
            Tree* result = cst2ast(*it); // 将一个子节点扔给另一个自己处理
            if (result == nullptr) it = c.erase(it); // 如果其返回 nullptr, 则擦去它
            else { // 否则
                *it = result; // 使用它
                it ++; // 调到下一个迭代器
            }
        }
    }
    if (c.empty()) return nullptr; // 如果是空的,直接返回 nullptr (算是标记吧)
    if (c.size() == 1) return c[0]; // 如果只要一个子节点,就单独返回它,不包括自己
    return tr; // 最后剩下的一个完美的 Tree
}
</code></pre>
<p>注意: 在循环中, 如果是空集(treeTypeNode_Epsilon), 并且 <code>it = c.erase(it)</code>, 那么就不需要<code>it ++</code>了, 所以 for 循环的第三个表达式是空的, 之后根据情况再在循环体内写<br />
它的结果与我自己动手做成的完全一样, 不过只有那些线不一样, 这就该埋怨我的 Tree::display() 了, 详见<a href="parser/display_a_tree.html">打印一棵树</a></p>
<h2 id="两天后"><a class="header" href="#两天后">两天后</a></h2>
<p>其实这样输出的也并不是十分的 AST, 因为撇来撇去的，所以我想再加上一些语句把一些撇去掉，只保留...那叫什么东西<br />
反正就是，原来是这样的</p>
<pre><code>Node Expr
├── Token Int [1]
└── Node Expr'
│   ├── Token Sign [+]
│   └── Token Int [3]
</code></pre>
<p>操作之后就变成</p>
<pre><code>Node Expr
├── Token Int [1]
├── Token Sign [+]
└── Token Int [3]
</code></pre>
<p>我想你懂我的意思。感觉也简单，就是在 <code>return tr;</code> 前加上一些判断的代码, 再做一些什么操作，不过要有一个函数判断是不是带撇的<br />
稍等<br />
不过，突然感觉没那个必要了，刚写的代码放这里纪念一下(说不定中间代码生成时有用)</p>
<pre><code class="language-cpp">bool treeTypeNodeLabelIs_(treeTypeNodeLabel label) {
    switch(label) {
        case treeTypeNode_Main: return false;
        case treeTypeNode_None: return false;
        case treeTypeNode_Epsilon: return false;
        case treeTypeNode_Expr: return false;
        case treeTypeNode_Expr_: return true;
        case treeTypeNode_Term: return false;
        case treeTypeNode_Term_: return true;
        case treeTypeNode_Factor: return false;
    }
    return false;
}
bool treeTypeNodeLabelTogether(treeTypeNodeLabel l1, treeTypeNodeLabel l2) {
    if (l1 == treeTypeNode_Expr &amp;&amp; l2 == treeTypeNode_Expr_) return true;
    if (l1 == treeTypeNode_Term &amp;&amp; l2 == treeTypeNode_Term_) return true;
    return false;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="小结parse-加减乘除"><a class="header" href="#小结parse-加减乘除">小结：parse 加减乘除</a></h1>
<p>截止现在(2024/8/5 14:18), Abandon 已经能够将任意的加减乘除解析为 CST 了<br />
比如输入<code>(10-2)*4</code>, 能够解析出树:</p>
<pre><code>Node Expr
├── Node Term
│   ├── Node Factor
│   │   └── Node Expr
│   │   │   ├── Node Term
│   │   │   │   ├── Node Factor
│   │   │   │   │   └── Token Int [10]
│   │   │   │   └── Node ε
│   │   │   └── Node Expr'
│   │   │   │   ├── Token Sign [-]
│   │   │   │   ├── Node Term
│   │   │   │   │   ├── Node Factor
│   │   │   │   │   │   └── Token Int [2]
│   │   │   │   │   └── Node ε
│   │   │   │   └── Node ε
│   └── Node Term'
│   │   ├── Token Sign [*]
│   │   ├── Node Factor
│   │   │   └── Token Int [4]
│   │   └── Node ε
└── Node ε
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="打印一棵树"><a class="header" href="#打印一棵树">打印一棵树</a></h1>
<h2 id="介绍一哈"><a class="header" href="#介绍一哈">介绍一哈</a></h2>
<p>我的树大概长这样</p>
<pre><code class="language-cpp">class Tree {
    treeType type;
    Token tk;
    treeTypeNodeLabel label;
    std::vector&lt;Tree*&gt; children;
};
</code></pre>
<p>然后有一堆枚举</p>
<pre><code class="language-cpp">enum treeType {
    treeType_End,
    treeType_Token,
    treeType_Node
};

enum treeTypeNodeLabel {
    treeTypeNode_Main,
    treeTypeNode_None,
    treeTypeNode_Epsilon,
    treeTypeNode_Expr,
    treeTypeNode_Expr_,
    treeTypeNode_Term,
    treeTypeNode_Term_,
    treeTypeNode_Factor,
};
</code></pre>
<p>在树中，根据 <code>label</code> 判断是一个是否是树中的叶子节点, <code>type</code> 是表示非子节点的类型, <code>children</code> 是表示非子节点的子节点(们), <code>tk</code> 表示 Token, 是一个叶子结点的值.<br />
我的这个 Tree 一般存储堆中, 使用 <code>createTree()</code> 函数(们)创建.<br />
在用这颗树的时候, 先判断 <code>label</code>, 然后在使用 [<code>type</code> 与 <code>children</code>] 或 [<code>tk</code>].</p>
<h2 id="打印一棵树-1"><a class="header" href="#打印一棵树-1">打印一棵树</a></h2>
<p>因此可以这样：</p>
<pre><code class="language-cpp">void Tree::display(int indent, bool last) {
    for (int i = 0; i &lt; indent - 1; ++i) { // 打印缩进
        std::cout &lt;&lt; (i &lt; indent - 1 ? "│   " : "    ");
    }

    if (indent &gt; 0) { // 打印树枝
        std::cout &lt;&lt; (last ? "└── " : "├── ");
    }

    if (this-&gt;type == treeType_Token) { // 打印 Token
        std::cout &lt;&lt; "Token " &lt;&lt; this-&gt;tk.typeToText()
                  &lt;&lt; " [" &lt;&lt; this-&gt;tk.content &lt;&lt; ']' &lt;&lt; std::endl;  // 打印 Token 类型及内容
    } else { // 打印非 Token 节点(Node)
        std::cout &lt;&lt; "Node " &lt;&lt; treeTypeNodeLabelToText(this-&gt;label) &lt;&lt; std::endl; // 打印节点类型

        for (size_t i = 0; i &lt; this-&gt;children.size(); ++i) { // 打印子节点(们)
            this-&gt;children[i]-&gt;display(indent + 1, i == this-&gt;children.size() - 1); // 递归打印
        }
    }
}
</code></pre>
<p>完毕！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="一些对我来说比较新鲜的东西"><a class="header" href="#一些对我来说比较新鲜的东西">一些对我来说比较新鲜的东西</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gdb-这么好用"><a class="header" href="#gdb-这么好用">GDB 这么好用？</a></h1>
<blockquote>
<p>以前，我只有一个时候使用 gdb，那就是-查看程序的汇编代码的时候<br />
我确实是大材小用了，</p>
</blockquote>
<p>我以前调试程序都是直接在代码中 print 变量的值，再简单点就是加一个宏，比如</p>
<pre><code class="language-cpp">#define DEBUG(info) std::cout &lt;&lt; "[INFO] " &lt;&lt; info &lt;&lt; std::endl;
</code></pre>
<p>这时候我的宏的参数都是不加括号的，因为可以这样玩 <code>DEBUG("Point 1: " &lt;&lt; var)</code><br />
在写这个 project 的时候我才真正使用 gdb 调试程序</p>
<h1 id="gdb"><a class="header" href="#gdb">GDB</a></h1>
<ol>
<li>编译源程序时加上 <code>-g</code> 参数，生成调试信息</li>
<li>运行 <code>gdb your_program</code> 命令，进入 gdb 调试环境<br />
这里的 <code>your_program</code> 是你编译后的可执行文件</li>
<li>输入 <code>break</code> 命令，设置断点，程序运行到这里会自动暂停
比如在 启动函数 <code>func</code> 处设置断点，输入 <code>break func</code><br />
这里的 <code>break</code> 可以简写成 <code>b</code></li>
<li>输入 <code>run</code> 命令运行程序，程序会在 gdb 调试环境中运行<br />
这里的 <code>run</code> 可以简写成 <code>r</code></li>
<li>输入 <code>next</code> 命令，单步执行程序，遇到断点会自动暂停
这里的 <code>next</code> 可以简写成 <code>n</code></li>
<li>输入 <code>continue</code> 命令，继续运行程序，遇到断点会自动暂停<br />
这里的 <code>continue</code> 可以简写成 <code>c</code></li>
<li>输入 <code>print</code> 命令，查看变量的值<br />
这里的 <code>print</code> 可以简写成 <code>p</code></li>
<li>输入 <code>backtrace</code> 命令，查看函数调用栈<br />
这里的 <code>backtrace</code> 可以简写成 <code>bt</code></li>
<li>输入 <code>quit</code> 命令，退出 gdb 调试环境<br />
这里的 <code>quit</code> 可以简写成 <code>q</code></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="截止目前所有的上下文无关文法"><a class="header" href="#截止目前所有的上下文无关文法">截止目前所有的上下文无关文法</a></h1>
<pre><code>Expr -&gt; Assignment
Assign -&gt; Add Assign'
Assign' -&gt; = Add Assign' | ε
Add   -&gt; Term Expr'
Add'  -&gt; + Term Expr' | - Term Expr' | ε
Term   -&gt; Factor Term'
Term'  -&gt; * Factor Term' | / Factor Term' | ε
Factor -&gt; ( Expr ) | Int
ExprList -&gt; Expr ExprList' | ε
ExprList' -&gt; , Expr ExprList' | ε
FunctionCall -&gt; @ Id ( ExprList )
Sentence -&gt; Expr ;
Sentences -&gt; Sentence Sentences | Sentence
Statements -&gt; { Sentences } | Sentence

DefineFuction -&gt; fn Id ( ExprList ) Statements
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="这个类似文档的东西是怎么来的"><a class="header" href="#这个类似文档的东西是怎么来的">这个类似文档的东西是怎么来的</a></h1>
<p>刚开始，我想写着代码（Abandon），有了逻辑错误，感觉有点懒了，那就....写写其他的？<br />
比如文档.</p>
<p>刚开始我用语雀写，写了一个“逃 Error”，然后，分享....<br />
哎，要会员，要实名.</p>
<p>那就算了，我说的是语雀，<br />
我看看其他的吧，<br />
用什么？Gitbook？登不上，<br />
Notion？有点慢</p>
<p>自建一个静态网页放到 Github Pages 上？<br />
（Github Pages 在河南好像挺快的）</p>
<p>网上搜了搜，看到了 nextra，界面看起来挺好看的，<br />
试了试，烦，node.js 还没装<br />
装上了，安装其他库，
好了，现在 <code>node_modules</code> 变成无底洞了<br />
好了，又 Error 了一大堆<br />
逃吧</p>
<p>最后，我用了这个叫做 mdbook 的东西，<br />
虽然界面比不上 nextra，<br />
但重要的是不需要 node.js 了,<br />
它是用 Rust 写的，但有编译好的二进制文件，直接 download 下来了，
我这就把 node 卸了<br />
稍等</p>
<p>好了，现在就可以愉快地写了</p>
<p>总之就是 \(语雀\to Gitbook\to Notion\to Nextra\to mdbook\)<br />
没事，我就试试 LaTeX 公式</p>
<p>好啦，现在我要 commit + push 了</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
